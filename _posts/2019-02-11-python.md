---
ID: 12
post_title: Python
author: admin
post_excerpt: ""
layout: post
permalink: https://cscourses.online/topics/python/
published: true
post_date: 2019-02-11 18:27:02
---
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=gbk">
  </head>
  <body>
    <h2>Python Introduction</h2>
    <p>Python is a general-purpose programming language that supports procedural, functional, and object-oriented paradigms.</p>
    <h3>Python Installation</h3>
    <p>You can download and install Python from <a href="https://www.python.org/">Python Offical Website</a></p>
    <h3>Python "Hello, World!"</h3>
    <p>Python code can run from Python interpreter directly.</p>
    <pre>C:&gt;python
Python 3.7.1 (v3.7.1:260ec2c36a, Oct 20 2018, 14:57:15) [MSC v.1915 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; print("Hello, World!")
Hello, World!
&gt;&gt;&gt;
</pre>
    <p>Python code also can be run as a script file. </p>
    <p>HelloWorld.py</p>
    <pre>print("Hello, World!");
</pre>
    <p>The result is, </p>
    <pre>C:&gt;python HelloWorld.py
Hello, World!

C:&gt;
</pre>
    <p>Python first compiles the source code into a format known as byte code, then executes the byte code in PVM (Python Virtual Machine).</p>
    <h2>Python Types and Operations</h2>
    <h3>Python Numbers</h3>
    <p>Python supports integers, floating-point numbers. Python can write integers using hexadecimal, octal, and binary literals. Python also offers a complex number type.</p>
    <pre>&gt;&gt;&gt; type(1)
&lt;class 'int'&gt;
&gt;&gt;&gt; type(1.1)
&lt;class 'float'&gt;
&gt;&gt;&gt; type(0x1)
&lt;class 'int'&gt;
&gt;&gt;&gt; type(1+1j)
&lt;class 'complex'&gt;
&gt;&gt;&gt;
</pre>
    <p>Python expression operators and precedence</p>
    <table>
      <thead>
        <tr>
          <td>Operators</td>
          <td>Description</td>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>yield x</td>
          <td>Generator function send protocol</td>
        </tr>
        <tr>
          <td>lambda args: expression</td>
          <td>Anonymous function generation</td>
        </tr>
        <tr>
          <td>x if y else z</td>
          <td>Ternary selection (x is evaluated only if y is true)</td>
        </tr>
        <tr>
          <td>x or y</td>
          <td>Logical OR (y is evaluated only if x is false)</td>
        </tr>
        <tr>
          <td>x and y</td>
          <td>Logical AND (y is evaluated only if x is true)</td>
        </tr>
        <tr>
          <td>not x</td>
          <td>Logical negation</td>
        </tr>
        <tr>
          <td>x in y, x not in y</td>
          <td>Membership (iterables, sets)</td>
        </tr>
        <tr>
          <td>x is y, x is not y</td>
          <td>Object identity tests</td>
        </tr>
        <tr>
          <td>x &lt; y, x &lt;= y, x &gt; y, x &gt;= y</td>
          <td>Magnitude comparison, set subset and superset;</td>
        </tr>
        <tr>
          <td>x == y, x != y</td>
          <td>Value equality operators</td>
        </tr>
        <tr>
          <td>x | y</td>
          <td>Bitwise OR, set union</td>
        </tr>
        <tr>
          <td>x ^ y</td>
          <td>Bitwise XOR, set symmetric difference</td>
        </tr>
        <tr>
          <td>x &amp; y</td>
          <td>Bitwise AND, set intersection</td>
        </tr>
        <tr>
          <td>x &lt;&lt; y, x &gt;&gt; y</td>
          <td> Shift x left or right by y bits</td>
        </tr>
        <tr>
          <td>x + y</td>
          <td> Addition, concatenation;</td>
        </tr>
        <tr>
          <td>x – y</td>
          <td> Subtraction, set difference</td>
        </tr>
        <tr>
          <td>x * y</td>
          <td> Multiplication, repetition;</td>
        </tr>
        <tr>
          <td>x % y</td>
          <td> Remainder, format;</td>
        </tr>
        <tr>
          <td>x / y, x // y</td>
          <td> Division: true and floor</td>
        </tr>
        <tr>
          <td>−x, +x</td>
          <td> Negation, identity</td>
        </tr>
        <tr>
          <td>˜x</td>
          <td> Bitwise NOT (inversion)</td>
        </tr>
        <tr>
          <td>x ** y</td>
          <td> Power (exponentiation)</td>
        </tr>
        <tr>
          <td>x[i]</td>
          <td> Indexing (sequence, mapping, others)</td>
        </tr>
        <tr>
          <td>x[i:j:k]</td>
          <td> Slicing</td>
        </tr>
        <tr>
          <td>x(...)</td>
          <td> Call (function, method, class, other callable)</td>
        </tr>
        <tr>
          <td>x.attr</td>
          <td> Attribute reference</td>
        </tr>
        <tr>
          <td>(...)</td>
          <td> Tuple, expression, generator expression</td>
        </tr>
        <tr>
          <td>[...]</td>
          <td> List, list comprehension</td>
        </tr>
        <tr>
          <td>{...}</td>
          <td> Dictionary, set, set and dictionary comprehensions </td>
        </tr>
      </tbody>
    </table>
    <p>Python built-in mathematical functions includes pow, abs, round, int, hex, bin, etc. </p>
    <p>Python utility modules includes random, math, etc. </p>
    <p>Python has an explicit Boolean data type called bool, with the values True and False.</p>
    <p>In Python, types are determined automatically at runtime, not in response to declarations in your code. This means that you never declare variables ahead of time.</p>
    <pre>&gt;&gt;&gt; a=1
&gt;&gt;&gt; type(a)
&lt;class 'int'&gt;
&gt;&gt;&gt; a=1.1
&gt;&gt;&gt; type(a)
&lt;class 'float'&gt;
&gt;&gt;&gt;    
</pre>
    <h3>Python Strings</h3>
    <p>In Python 3.X there are three string types: str is used for Unicode text (including ASCII), bytes is used for binary data (including encoded text), and bytearray is a mutable variant of bytes.</p>
    <p>Common string literals and operations</p>
    <table>
      <thead>
        <tr>
          <td>Operation</td>
          <td>Interpretation</td>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>''</td>
          <td>Empty string</td>
        </tr>
        <tr>
          <td>"I'm"</td>
          <td>Double quotes, same as single</td>
        </tr>
        <tr>
          <td>'s\na\tme'</td>
          <td>Escape sequences</td>
        </tr>
        <tr>
          <td>"""...multiline..."""</td>
          <td>Triple-quoted block strings</td>
        </tr>
        <tr>
          <td>r'nr'</td>
          <td>Raw strings (no escapes)</td>
        </tr>
        <tr>
          <td>b'anb'</td>
          <td>Byte strings</td>
        </tr>
        <tr>
          <td>u'au00c4b'</td>
          <td>Unicode strings</td>
        </tr>
        <tr>
          <td>S1 + S2<br>
            S * 3</td>
          <td>Concatenate, repeat</td>
        </tr>
        <tr>
          <td>S[i]<br>
            S[i:j]<br>
            len(S)</td>
          <td>Index, slice, length</td>
        </tr>
        <tr>
          <td>"a %s parrot" % kind</td>
          <td>String formatting expression</td>
        </tr>
        <tr>
          <td>"a {0} parrot".format(kind)</td>
          <td>String formatting method</td>
        </tr>
        <tr>
          <td>S.find('pa')<br>
            S.rstrip()<br>
            S.replace('pa', 'xx')<br>
            S.split(',')</td>
          <td>String methods</td>
        </tr>
        <tr>
          <td>S.encode('latin-1')</td>
          <td>Unicode encoding</td>
        </tr>
        <tr>
          <td>B.decode('utf8')</td>
          <td>Unicode decoding</td>
        </tr>
        <tr>
          <td>[c * 2 for c in S]</td>
          <td>Iteration, membership</td>
        </tr>
        <tr>
          <td>re.match('sp(.*)am', line)</td>
          <td>Pattern matching: library module</td>
        </tr>
      </tbody>
    </table>
    <p>String backslash characters</p>
    <table>
      <thead>
      </thead>
      <tbody>
        <tr>
          <td>Escape</td>
          <td>Meaning</td>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td>newline</td>
          <td>Ignored (continuation line)</td>
        </tr>
        <tr>
          <td>\</td>
          <td>Backslash (stores one )</td>
        </tr>
        <tr>
          <td>'</td>
          <td>Single quote (stores ')</td>
        </tr>
        <tr>
          <td>"</td>
          <td>Double quote (stores ")</td>
        </tr>
        <tr>
          <td>a</td>
          <td>Bell</td>
        </tr>
        <tr>
          <td>b</td>
          <td>Backspace</td>
        </tr>
        <tr>
          <td>f</td>
          <td>Formfeed</td>
        </tr>
        <tr>
          <td>n</td>
          <td>Newline (linefeed)</td>
        </tr>
        <tr>
          <td>r</td>
          <td>Carriage return</td>
        </tr>
        <tr>
          <td>t</td>
          <td>Horizontal tab</td>
        </tr>
        <tr>
          <td>v</td>
          <td>Vertical tab</td>
        </tr>
        <tr>
          <td>xhh</td>
          <td>Character with hex value hh (exactly 2 digits)</td>
        </tr>
        <tr>
          <td>ooo</td>
          <td>Character with octal value ooo (up to 3 digits)</td>
        </tr>
        <tr>
          <td>�</td>
          <td>Null: binary 0 character (doesn't end string)</td>
        </tr>
        <tr>
          <td>N{id}</td>
          <td>Unicode database ID</td>
        </tr>
        <tr>
          <td>uhhhh</td>
          <td>Unicode character with 16-bit hex value</td>
        </tr>
        <tr>
          <td>Uhhhhhhhh</td>
          <td>Unicode character with 32-bit hex valuea</td>
        </tr>
        <tr>
          <td>other</td>
          <td>Not an escape (keeps both  and other)</td>
        </tr>
      </tbody>
    </table>
    <p>String method calls include, </p>
    <pre>      
S.capitalize() 
S.casefold()
S.center(width [, fill]) 
S.count(sub [, start [, end]]) 
S.encode([encoding [,errors]])
S.endswith(suffix [, start [, end]]) 
S.expandtabs([tabsize]) 
S.find(sub [, start [, end]]) 
S.format(fmtstr, *args, **kwargs)
S.index(sub [, start [, end]])
S.isalnum()
S.isalpha() 
S.isdecimal() 
S.isdigit() 
S.isidentifier()
S.islower() 
S.isnumeric() 
S.isprintable() 
S.isspace() 
S.istitle() 
S.isupper() 
S.join(iterable)    
S.ljust(width [, fill])
S.lower() 
S.lstrip([chars])  
S.maketrans(x[, y[, z]])
S.partition(sep)
S.replace(old, new [, count])  
S.rfind(sub [,start [,end]])
S.rindex(sub [, start [, end]]) 
S.rjust(width [, fill])   
S.rpartition(sep)     
S.rsplit([sep[, maxsplit]])  
S.rstrip([chars])   
S.split([sep [,maxsplit]])   
S.splitlines([keepends])
S.startswith(prefix [, start [, end]])
S.strip([chars])
S.swapcase()      
S.title()      
S.translate(map)      
S.upper()      
S.zfill(width)      
</pre>
    <p>Python string formatting supports all the usual C printf format codes.</p>
    <table>
      <thead>
        <tr>
          <td>Code</td>
          <td>Meaning</td>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>s</td>
          <td> String (or any object’s str(X) string)</td>
        </tr>
        <tr>
          <td>r</td>
          <td> Same as s, but uses repr, not str</td>
        </tr>
        <tr>
          <td>c</td>
          <td> Character (int or str)</td>
        </tr>
        <tr>
          <td>d</td>
          <td> Decimal (base-10 integer)</td>
        </tr>
        <tr>
          <td>i</td>
          <td> Integer</td>
        </tr>
        <tr>
          <td>u</td>
          <td> Same as d (obsolete: no longer unsigned)</td>
        </tr>
        <tr>
          <td>o</td>
          <td> Octal integer (base 8)</td>
        </tr>
        <tr>
          <td>x</td>
          <td> Hex integer (base 16)</td>
        </tr>
        <tr>
          <td>X</td>
          <td> Same as x, but with uppercase letters</td>
        </tr>
        <tr>
          <td>e</td>
          <td> Floating point with exponent, lowercase</td>
        </tr>
        <tr>
          <td>E</td>
          <td> Same as e, but uses uppercase letters</td>
        </tr>
        <tr>
          <td>f</td>
          <td> Floating-point decimal</td>
        </tr>
        <tr>
          <td>F</td>
          <td> Same as f, but uses uppercase letters</td>
        </tr>
        <tr>
          <td>g</td>
          <td> Floating-point e or f</td>
        </tr>
        <tr>
          <td>G</td>
          <td> Floating-point E or F</td>
        </tr>
        <tr>
          <td>%</td>
          <td> Literal % (coded as %%)</td>
        </tr>
      </tbody>
    </table>
    <h3>Python Lists</h3>
    <p>Python lists are ordered collections of arbitrary objects. Objects are accessed by offset.</p>
    <p>Common list literals and operations,</p>
    <table>
      <thead>
        <tr>
          <td>Operation</td>
          <td>Interpretation</td>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>[]</td>
          <td>An empty list</td>
        </tr>
        <tr>
          <td>[123, 'abc', 1.23, {}]</td>
          <td>Four items: indexes 0..3</td>
        </tr>
        <tr>
          <td>['Bob', 40.0, ['dev', 'mgr']]</td>
          <td>Nested sublists</td>
        </tr>
        <tr>
          <td>list('spam')<br>
            list(range(-4, 4))</td>
          <td>List of an iterable’s items, list of successive integers</td>
        </tr>
        <tr>
          <td>L[i]<br>
            L[i][j]<br>
            L[i:j]<br>
            len(L)</td>
          <td>Index, index of index, slice, length</td>
        </tr>
        <tr>
          <td>L1 + L2<br>
            L * 3</td>
          <td>Concatenate, repeat</td>
        </tr>
        <tr>
          <td>for x in L: print(x)<br>
            3 in L</td>
          <td>Iteration, membership</td>
        </tr>
        <tr>
          <td>L.append(4)<br>
            L.extend([5,6,7])<br>
            L.insert(i, X)</td>
          <td>Methods: growing</td>
        </tr>
        <tr>
          <td>L.index(X)<br>
            L.count(X)</td>
          <td>Methods: searching</td>
        </tr>
        <tr>
          <td>L.sort()<br>
            L.reverse()<br>
            L.copy()<br>
            L.clear()</td>
          <td>Methods: sorting, reversing,copying, clearing</td>
        </tr>
        <tr>
          <td>L.pop(i)<br>
            L.remove(X)<br>
            del L[i]<br>
            del L[i:j]<br>
            L[i:j] = []</td>
          <td>Methods, statements: shrinking</td>
        </tr>
        <tr>
          <td>L[i] = 3<br>
            L[i:j] = [4,5,6]</td>
          <td>Index assignment, slice assignment</td>
        </tr>
        <tr>
          <td>L = [x**2 for x in range(5)]<br>
            list(map(ord, 'spam'))</td>
          <td>List comprehensions and maps</td>
        </tr>
      </tbody>
    </table>
    <h3>Python Dictionaries</h3>
    <p>Python dictionaries are unordered collections of arbitrary objects. Objects are accessed by key.</p>
    <p>Common dictionary literals and operations,</p>
    <table>
      <thead>
        <tr>
          <td>Operation</td>
          <td>Interpretation</td>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>{}</td>
          <td>Empty dictionary</td>
        </tr>
        <tr>
          <td>{'name': 'Bob', 'age': 40}</td>
          <td>Two-item dictionary</td>
        </tr>
        <tr>
          <td>E = {'cto': {'name': 'Bob', 'age': 40}}</td>
          <td>Nesting</td>
        </tr>
        <tr>
          <td> D = dict(name='Bob', age=40)<br>
            D = dict([('name', 'Bob'), ('age', 40)])<br>
            D = dict(zip(keyslist, valueslist))<br>
            D = dict.fromkeys(['name', 'age']) </td>
          <td> Alternative construction techniques: keywords, key/value pairs, zipped key/value pairs, key lists </td>
        </tr>
        <tr>
          <td> D['name']<br>
            E['cto']['age'] </td>
          <td> Indexing by key </td>
        </tr>
        <tr>
          <td> 'age' in D </td>
          <td>Membership: key present test </td>
        </tr>
        <tr>
          <td>D.keys() </td>
          <td>Methods: all keys, </td>
        </tr>
        <tr>
          <td>D.values() </td>
          <td>all values, </td>
        </tr>
        <tr>
          <td>D.items() </td>
          <td>all key+value tuples, </td>
        </tr>
        <tr>
          <td>D.copy() </td>
          <td>copy (top-level), </td>
        </tr>
        <tr>
          <td>D.clear() </td>
          <td>clear (remove all items), </td>
        </tr>
        <tr>
          <td> D.update(D2) </td>
          <td>merge by keys, </td>
        </tr>
        <tr>
          <td>D.get(key, default?) </td>
          <td>fetch by key, if absent default (or None), </td>
        </tr>
        <tr>
          <td>D.pop(key, default?) </td>
          <td>remove by key, if absent default (or error) </td>
        </tr>
        <tr>
          <td>D.setdefault(key, default?)</td>
          <td>fetch by key, if absent set default (or None),</td>
        </tr>
        <tr>
          <td>D.popitem()</td>
          <td>remove/return any (key, value) pair; etc.</td>
        </tr>
        <tr>
          <td>len(D)</td>
          <td>Length: number of stored entries</td>
        </tr>
        <tr>
          <td>D[key] = 42</td>
          <td>Adding/changing keys</td>
        </tr>
        <tr>
          <td>del D[key]</td>
          <td>Deleting entries by key</td>
        </tr>
        <tr>
          <td>list(D.keys())<br>
            D1.keys() &amp; D2.keys()</td>
          <td>Dictionary views</td>
        </tr>
        <tr>
          <td>D = {x: x*2 for x in range(10)}</td>
          <td>Dictionary comprehensions</td>
        </tr>
      </tbody>
    </table>
    <h3>Python Tuples</h3>
    <p>Tuples are ordered collections of arbitrary objects. Objects are accessed by offset. Tuples are immutable</p>
    <p>Common tuple literals and operations</p>
    <table>
      <thead>
        <tr>
          <td>Operation</td>
          <td>Interpretation</td>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>()</td>
          <td>An empty tuple</td>
        </tr>
        <tr>
          <td>T = (0,)</td>
          <td>A one-item tuple</td>
        </tr>
        <tr>
          <td>T = (0, 'Ni', 1.2, 3)</td>
          <td>A four-item tuple</td>
        </tr>
        <tr>
          <td>T = 0, 'Ni', 1.2, 3</td>
          <td>Another four-item tuple</td>
        </tr>
        <tr>
          <td>T = ('Bob', ('dev', 'mgr'))</td>
          <td>Nested tuples</td>
        </tr>
        <tr>
          <td>T = tuple('spam')</td>
          <td>Tuple of items in an iterable</td>
        </tr>
        <tr>
          <td>T[i]<br>
            T[i][j]<br>
            T[i:j]<br>
            len(T)</td>
          <td>Index, index of index, slice, length</td>
        </tr>
        <tr>
          <td>T1 + T2<br>
            T * 3</td>
          <td>Concatenate, repeat</td>
        </tr>
        <tr>
          <td>for x in T: print(x)<br>
            'spam' in T<br>
            [x ** 2 for x in T]</td>
          <td>Iteration, membership</td>
        </tr>
        <tr>
          <td>T.index('Ni')<br>
            T.count('Ni')</td>
          <td>Tuple methods: search, count</td>
        </tr>
        <tr>
          <td> namedtuple('Emp', ['name', 'jobs'])</td>
          <td>Named tuple extension type</td>
        </tr>
      </tbody>
    </table>
    <h3>Python Files</h3>
    <p>Common file operations</p>
    <table>
      <thead>
        <tr>
          <td>Operation</td>
          <td>Interpretation</td>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>output = open(r'C:spam', 'w')</td>
          <td>Create output file ('w' means write)</td>
        </tr>
        <tr>
          <td>input = open('data', 'r')</td>
          <td>Create input file ('r' means read)</td>
        </tr>
        <tr>
          <td>input = open('data')</td>
          <td>Same as prior line ('r' is the default)</td>
        </tr>
        <tr>
          <td>aString = input.read()</td>
          <td>Read entire file into a single string</td>
        </tr>
        <tr>
          <td>aString = input.read(N)</td>
          <td>Read up to next N characters (or bytes) into a string</td>
        </tr>
        <tr>
          <td>aString = input.readline()</td>
          <td>Read next line (including n newline) into a string</td>
        </tr>
        <tr>
          <td>aList = input.readlines()</td>
          <td>Read entire file into list of line strings (with n)</td>
        </tr>
        <tr>
          <td><br>
          </td>
          <td><br>
          </td>
        </tr>
        <tr>
          <td>output.write(aString)</td>
          <td> Write a string of characters (or bytes) into file</td>
        </tr>
        <tr>
          <td>output.writelines(aList) </td>
          <td>Write all line strings in a list into file</td>
        </tr>
        <tr>
          <td>output.close()</td>
          <td> Manual close (done for you when file is collected)</td>
        </tr>
        <tr>
          <td>output.flush()</td>
          <td> Flush output buffer to disk without closing</td>
        </tr>
        <tr>
          <td>anyFile.seek(N)</td>
          <td> Change file position to offset N for next operation</td>
        </tr>
        <tr>
          <td>for line in open('data'): use line </td>
          <td>File iterators read line by line</td>
        </tr>
        <tr>
          <td>open('f.txt', encoding='latin-1')</td>
          <td> Python Unicode text files (str strings)</td>
        </tr>
        <tr>
          <td>open('f.bin', 'rb')</td>
          <td> Python bytes files (bytes strings)</td>
        </tr>
      </tbody>
    </table>
    <h2>Python Statements</h2>
    <h3>Python Assignment Statements</h3>
    <table>
      <thead>
        <tr>
          <td>Operation</td>
          <td>Interpretation</td>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>spam = 'Spam'</td>
          <td>Basic form</td>
        </tr>
        <tr>
          <td>spam, ham = 'yum', 'YUM'</td>
          <td>Tuple assignment (positional)</td>
        </tr>
        <tr>
          <td>[spam, ham] = ['yum', 'YUM']</td>
          <td>List assignment (positional)</td>
        </tr>
        <tr>
          <td>a, b, c, d = 'spam'</td>
          <td> Sequence assignment, generalized</td>
        </tr>
        <tr>
          <td>a, *b = 'spam'</td>
          <td>Extended sequence unpacking</td>
        </tr>
        <tr>
          <td>spam = ham = 'lunch' </td>
          <td>Multiple-target assignment</td>
        </tr>
        <tr>
          <td>spams += 42 </td>
          <td>Augmented assignment (equivalent to spams = spams + 42)</td>
        </tr>
      </tbody>
    </table>
    <h3>Python if Statements</h3>
    <p>The Python if statement is typical of if statements in most procedural languages</p>
    <pre>if test1: # if test
  statements1 # Associated block
elif test2: # Optional elifs
  statements2   
else: # Optional else
  statements3  
</pre>
    <h3>Python while Loops</h3>
    <p>Python's while statement repeatedly executes a block of statements as long as a test at the top keeps evaluating to a true value.</p>
    <pre>while test:
  statements
  if test: break # Exit loop now, skip else if present
  if test: continue # Go to top of loop now, to test1
else:
  statements # Run if we didn't hit a 'break'    
</pre>
    <p><b>break,</b> Jumps out of the closest enclosing loop (past the entire loop statement)</p>
    <p><b>continue,</b> Jumps to the top of the closest enclosing loop (to the loop’s header line)</p>
    <p><b>pass,</b> Does nothing at all: it’s an empty statement placeholder</p>
    <h3>Python for Loops</h3>
    <p>The Python for loop begins with a header line that specifies an assignment target, along with the object you want to step through.</p>
    <pre>for target in object: # Assign object items to target
  statements
  if test: break # Exit loop now, skip else
  if test: continue # Go to top of loop now
else:
  statements # If we didn't hit a 'break'
</pre>
    <h3>Python Iteration</h3>
    <p>The iterable object you request iteration for, is run by iter;</p>
    <p>The iterator object returned by the iterable that produces values during the iteration, whose __next__ is run by next and raises StopIteration when finished producing results.</p>
    <pre>&gt;&gt;&gt; l = [1,2,3,4]
&gt;&gt;&gt; i = iter(l)
&gt;&gt;&gt; next(i)
1
&gt;&gt;&gt; next(i)
2
&gt;&gt;&gt;
</pre>
    <h3>Python List Comprehension</h3>
    <p>List comprehensions are written in square brackets because they are ultimately a way to construct a new list. They begin with an arbitrary expression, which uses a loop variable. That is followed by the header of a for loop, which names the loop variable, and an iterable object (for x in L).</p>
    <pre>L = [x + 10 for x in L]
</pre>
    <h2>Python Functions and Generators</h2>
    <h3>Python def Statements</h3>
    <p>The def statement creates a function object and assigns it to a name.</p>
    <pre>def name(arg1, arg2,... argN):
  ...
  return value
</pre>
    <h3>Python Scope</h3>
    <p>Names assigned inside a def can only be seen by the code within that def. You cannot even refer to such names from outside the function.</p>
    <p>Names assigned inside a def do not clash with variables outside the def, even if the same names are used elsewhere.</p>
    <p>If a variable is assigned inside a def, it is local to that function.</p>
    <p>If a variable is assigned in an enclosing def, it is nonlocal to nested functions.</p>
    <p>If a variable is assigned outside all defs, it is global to the entire file.</p>
    <p><b>global</b> makes scope lookup begin in the enclosing module's scope and allows names there to be assigned. Scope lookup continues on to the built-in scope if the name does not exist in the module, but assignments to global names always create or change them in the module’s scope.</p>
    <p><b>nonlocal</b> restricts scope lookup to just enclosing defs, requires that the names already exist there, and allows them to be assigned. Scope lookup does not continue on to the global or built-in scopes.</p>
    <h3>Python Factory Functions: Closures</h3>
    <p>Factory functions (a.k.a. closures) are sometimes used by programs that need to generate event handlers on the fly in response to conditions at runtime.</p>
    <pre>&gt;&gt;&gt; def maker(N):
  def action(X): # Make and return action
    return X ** N # action retains N from enclosing scope
  return action
</pre>
    <h3>Python Arguments</h3>
    <p>Arguments are passed by automatically assigning objects to local variable names.</p>
    <p>Assigning to argument names inside a function does not affect the caller.</p>
    <p>Changing a mutable object argument in a function may impact the caller.</p>
    <p>Immutable arguments are effectively passed "by value".</p>
    <p>Mutable arguments are effectively passed "by pointer".</p>
    <p>Python caller argument matching,</p>
    <table>
      <thead>
        <tr>
          <td>Syntax</td>
          <td>Interpretation</td>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>func(value)</td>
          <td>Normal argument: matched by position</td>
        </tr>
        <tr>
          <td>func(name=value)</td>
          <td>Keyword argument: matched by name</td>
        </tr>
        <tr>
          <td>func(*iterable)</td>
          <td>Pass all objects in iterable as individual positional arguments</td>
        </tr>
        <tr>
          <td>func(**dict)</td>
          <td>Pass all key/value pairs in dict as individual keyword arguments</td>
        </tr>
      </tbody>
    </table>
    <p>Python function argument matching,</p>
    <table>
      <thead>
        <tr>
          <td>Syntax</td>
          <td>Interpretation</td>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>def func(name)</td>
          <td>Function Normal argument: matches any passed value by position or name</td>
        </tr>
        <tr>
          <td>def func(name=value)</td>
          <td>Function Default argument value, if not passed in the call</td>
        </tr>
        <tr>
          <td>def func(*name)</td>
          <td>Function Matches and collects remaining positional arguments in a tuple</td>
        </tr>
        <tr>
          <td>def func(**name)</td>
          <td>Function Matches and collects remaining keyword arguments in a dictionary</td>
        </tr>
        <tr>
          <td>def func(*other, name)</td>
          <td>Function Arguments that must be passed by keyword only in calls</td>
        </tr>
        <tr>
          <td>def func(*, name=value)</td>
          <td>Function Arguments that must be passed by keyword only in calls</td>
        </tr>
      </tbody>
    </table>
    <h3>Python Recursive Functions</h3>
    <p>Python supports recursive functions—functions that call themselves either directly or indirectly in order to loop.</p>
    <h3>Python Indirect Function Calls</h3>
    <p>Because Python functions are objects, you can write programs that process them generically. Function objects may be assigned to other names, passed to other functions, embedded in data structures, returned from one function to another, and more, as if they were simple numbers or strings. Function objects also happen to support a special operation: they can be called by listing arguments in parentheses after a function expression.</p>
    <h2>Python Modules and Packages</h2>
    <h2>Python Classes and OOP</h2>
    <h2>Python Exceptions and Tools</h2>
    <h2>Python Advanced Topics</h2>
  </body>
</html>