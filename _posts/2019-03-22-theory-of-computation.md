---
ID: 821
post_title: Theory of Computation
author: admin
post_excerpt: ""
layout: post
permalink: >
  https://cscourses.online/topics/theory-of-computation/
published: true
post_date: 2019-03-22 14:42:28
---
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title></title>
  </head>
  <body>
    <h2>Theory of Computation Introduction</h2>
    <p>Theory of Computation is the research about what are the fundamental
      capabilities and limitations of computers.</p>
    <h2>Automata and Languages</h2>
    <h3>Automata</h3>
    <p>Finite automata are good models for computers with an extremely limited
      amount of memory.</p>
    <p>A finite automaton has several parts. It has a set of states and
      transition function for going from one state to another, depending on the
      input symbol. It has an input alphabet that indicates the allowed input
      symbols. It has a start state and a set of accept states. The formal
      definition says that a finite automaton is a list of those five objects:
      set of states, input alphabet, transition functions for moving, start
      state, and accept states.</p>
    <p>When the machine is in a given state and reads the next input symbol, we
      know what the next state will be — it is determined. We call this
      deterministic computation. In a nondeterministic machine, several choices
      may exist for the next state at any point.</p>
    <p>The difference between a DFA (deterministic finite automaton)&nbsp; and a
      NFA (nondeterministic finite automaton) is,</p>
    <ul>
      <li> First, in a DFA, every state has exactly one exiting transition arrow
        for each symbol in the alphabet. In an NFA , a state may have zero, one,
        or many exiting arrows for each alphabet symbol.</li>
      <li>Second, in a DFA , labels on the transition arrows are symbols from
        the alphabet. In an NFA, there may have arrows labeled with members of
        the alphabet or ε. Zero, one, or many arrows may exit from each state
        with the label ε.</li>
    </ul>
    <p>Every NFA has an equivalent DFA.</p>
    <h3>Regular Languages</h3>
    <p>A language is regular if and only if some NFA recognizes it. Regular
      language is generated by union and contatenation.</p>
    <h3>Context-Free Languages</h3>
    <p>Context-free languages can describe certain features that have<br>
      a recursive structure.</p>
    <h3>Pushdown Automata</h3>
    <p>Pushdown automata are like NFA but have an extra component called a
      stack. The stack provides additional memory beyond the finite amount
      available in the control. The stack allows pushdown automata to recognize
      context-free languages.</p>
    <h2>Computability Theory</h2>
    <h3>Turing Machine</h3>
    <p>The Turing machine model uses an infinite tape as its unlimited memory.
      It has a tape head that can read and write symbols and move around on the
      tape. Initially the tape contains only the input string and is blank
      everywhere else. If the machine needs to store information, it may write
      this information on the tape. To read the information that it has written,
      the machine can move its head back over it. The machine continues
      computing until it decides to produce an output.</p>
    <p>Regular language and context-free language are decidable.</p>
    <h2>Complexity Theory</h2>
    <h3>Time Complexity</h3>
    <p>P is the class of languages that are decidable in polynomial time on a
      deterministic single-tape Turing machine.</p>
    <p>NP is the class of languages that have polynomial time verifiers.</p>
    <h3>Space Complexity</h3>
    <p>the complexity of computational problems in terms
      of the amount of space, or memory, that they require.</p>
    <h3>Intractable</h3>
    <p>Certain computational problems are solvable in principle, but the
      solutions require so much time or space that they can’t be used in
      practice. Such problems are called intractable.</p>
  </body>
</html>